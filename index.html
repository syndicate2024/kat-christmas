<!DOCTYPE html>
<html>
	<head>
		<link
			href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600&display=swap"
			rel="stylesheet"
		/>
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
			#scene-container {
				position: fixed;
				width: 100%;
				height: 100%;
				background: url('winter-scene.jpg') no-repeat center center fixed;
				background-size: cover;
			}
			.message-container {
				position: fixed;
				bottom: 0;
				left: 0;
				right: 0;
				height: 22rem;
				display: flex;
				align-items: center;
				justify-content: center;
				background: linear-gradient(
					to top,
					rgba(0, 0, 0, 0.9) 0%,
					rgba(0, 0, 0, 0.8) 60%,
					transparent 100%
				);
				font-family: 'Cormorant Garamond', serif;
				color: white;
				z-index: 1000;
				opacity: 0;
				transition: opacity 2s ease-out;
			}
			.message-text {
				max-width: 800px;
				font-size: 1.8rem;
				line-height: 1.5;
				text-align: center;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
				margin-top: 8rem;
			}
			.start-heart {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				width: 150px;
				height: 150px;
				cursor: pointer;
				z-index: 2000;
				background: none;
				border: none;
				outline: none;
				animation: heartbeat 1.2s ease-in-out infinite;
			}
			.start-heart::after {
				content: '';
				position: absolute;
				top: 0;
				left: -50%;
				width: 200%;
				height: 100%;
				background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
				transform: skewX(-20deg);
				animation: shine 3s infinite;
			}
			@keyframes heartbeat {
				0% {
					transform: translate(-50%, -50%) scale(1);
				}
				5% {
					transform: translate(-50%, -50%) scale(1.15);
				}
				10% {
					transform: translate(-50%, -50%) scale(1.05);
				}
				15% {
					transform: translate(-50%, -50%) scale(1.2);
				}
				50% {
					transform: translate(-50%, -50%) scale(1);
				}
				100% {
					transform: translate(-50%, -50%) scale(1);
				}
			}
			@keyframes shine {
				0% {
					left: -50%;
					opacity: 0;
				}
				10% {
					opacity: 0.3;
				}
				20% {
					opacity: 0;
				}
				100% {
					left: 150%;
					opacity: 0;
				}
			}
			.fade-in {
				opacity: 1;
			}
			.hidden {
				display: none !important;
			}
		</style>
	</head>
	<body>
		<div id="scene-container"></div>
		<button class="start-heart" id="start-button">
			<svg viewBox="0 0 100 100" width="100%" height="100%">
				<path
					fill="#9370DB"
					d="M50,88.87 C76.67,70.46 90,53.9 90,39.17 C90,17.08 63.39,3.84 50,27.63 C36.61,3.84 10,17.08 10,39.17 C10,53.9 23.33,70.46 50,88.87 Z"
				/>
			</svg>
		</button>
		<div class="message-container">
			<div class="message-text">
				Though this is our first Christmas together, and we haven't been together for long, I know I
				love you more than I ever thought possible. I look forward to many more Christmas mornings
				with you. I can't imagine life without you by my side.
			</div>
		</div>
		<script type="module">
			import * as THREE from 'three';

			// Global state
			let hasClicked = false;
			let snowflakesVisible = false;
			let explosionParticles = [];
			let explosionTime = 0;
			const depthRange = { min: -20, max: 10 };

			// Audio setup
			const backgroundMusic = new Audio("Five_O'Clock_-_JEKK.mp3");
			backgroundMusic.loop = false;

			// Scene setup
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(
				75,
				window.innerWidth / window.innerHeight,
				0.1,
				1000
			);
			const renderer = new THREE.WebGLRenderer({
				alpha: true,
				antialias: true,
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('scene-container').appendChild(renderer.domElement);

			// Create detailed snowflake geometry
			function createSnowflakeGeometry(size) {
				const geometry = new THREE.BufferGeometry();
				const vertices = [];

				for (let i = 0; i < 6; i++) {
					const angle = (i * Math.PI * 2) / 6;
					vertices.push(0, 0, 0);
					vertices.push(Math.cos(angle) * size, Math.sin(angle) * size, 0);

					const subSize = size * 0.6;
					const subAngle1 = angle + Math.PI / 6;
					const subAngle2 = angle - Math.PI / 6;

					vertices.push(Math.cos(angle) * size * 0.5, Math.sin(angle) * size * 0.5, 0);
					vertices.push(
						Math.cos(angle) * size * 0.5 + Math.cos(subAngle1) * subSize * 0.5,
						Math.sin(angle) * size * 0.5 + Math.sin(subAngle1) * subSize * 0.5,
						0
					);

					vertices.push(Math.cos(angle) * size * 0.5, Math.sin(angle) * size * 0.5, 0);
					vertices.push(
						Math.cos(angle) * size * 0.5 + Math.cos(subAngle2) * subSize * 0.5,
						Math.sin(angle) * size * 0.5 + Math.sin(subAngle2) * subSize * 0.5,
						0
					);
				}

				geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
				return geometry;
			}

			// Create heart geometry
			function create3DHeartGeometry(size) {
				const x = 0,
					y = 0;

				const heartShape = new THREE.Shape();
				heartShape.moveTo(x + 25, y + 25);
				heartShape.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y);
				heartShape.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35);
				heartShape.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95);
				heartShape.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35);
				heartShape.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y);
				heartShape.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);

				const extrudeSettings = {
					depth: 8,
					bevelEnabled: true,
					bevelSegments: 8,
					steps: 2,
					bevelSize: 3,
					bevelThickness: 3,
				};

				const geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
				geometry.scale(size * 0.01, size * 0.01, size * 0.01);
				geometry.center();
				return geometry;
			}

			// Create snow particles
			const snowParticles = [];
			const particleCount = 1000;

			for (let i = 0; i < particleCount; i++) {
				const size = Math.random() * 0.5 + 0.3;
				const geometry = createSnowflakeGeometry(size);
				const material = new THREE.LineBasicMaterial({
					color: 0xffffff,
					transparent: true,
					opacity: Math.random() * 0.5 + 0.5,
				});

				const particle = new THREE.LineSegments(geometry, material);

				const zPos = Math.random() * (depthRange.max - depthRange.min) + depthRange.min;
				const spreadFactor = (zPos - depthRange.min) / (depthRange.max - depthRange.min);
				const spread = 150 - spreadFactor * 100;

				particle.position.set(Math.random() * spread - spread / 2, Math.random() * 200 - 100, zPos);

				particle.userData.rotationSpeed = (Math.random() - 0.5) * 0.01;
				particle.userData.fallSpeed = Math.random() * 0.15 + 0.01;
				particle.userData.wobbleSpeed = Math.random() * 0.02;
				particle.userData.wobbleAmplitude = Math.random() * 0.1;
				particle.userData.initialX = particle.position.x;
				particle.userData.zPos = zPos;

				snowParticles.push(particle);
			}

			// Create explosion particles function
			function createExplosionParticles(count) {
				const particles = [];
				const heartGeometry = create3DHeartGeometry(0.5);

				for (let i = 0; i < count; i++) {
					const material = new THREE.MeshPhongMaterial({
						color: 0xff0000,
						emissive: 0xff0000,
						emissiveIntensity: 0.5,
						shininess: 80,
						transparent: true,
						opacity: 0.9,
						side: THREE.DoubleSide,
					});

					const heart = new THREE.Mesh(heartGeometry, material);
					heart.position.set(0, 0, -10);

					const theta = Math.random() * Math.PI * 2;
					const phi = Math.random() * Math.PI;
					const speed = Math.random() * 0.5 + 0.5;

					heart.userData.velocity = new THREE.Vector3(
						Math.sin(phi) * Math.cos(theta),
						Math.sin(phi) * Math.sin(theta),
						Math.cos(phi)
					).multiplyScalar(speed);

					heart.userData.rotationSpeed = new THREE.Vector3(
						Math.random() - 0.5,
						Math.random() - 0.5,
						Math.random() - 0.5
					).multiplyScalar(0.05);

					particles.push(heart);
					scene.add(heart);
				}
				return particles;
			}

			// Add lighting
			const pointLight = new THREE.PointLight(0xffffff, 1);
			pointLight.position.set(0, 0, 5);
			scene.add(pointLight);

			const ambientLight = new THREE.AmbientLight(0x404040);
			scene.add(ambientLight);

			// Position camera
			camera.position.z = 15;

			// Click handler
			document.getElementById('start-button').addEventListener('click', function () {
				if (!hasClicked) {
					hasClicked = true;

					// Start music immediately
					backgroundMusic.play();

					// Create explosion immediately as heart disappears
					this.classList.add('hidden');
					explosionParticles = createExplosionParticles(100);
					explosionTime = Date.now();

					// Show text after 1 second
					setTimeout(() => {
						document.querySelector('.message-container').classList.add('fade-in');
					}, 1000);

					// Add snowflakes after explosion plus fade (3 seconds total)
					setTimeout(() => {
						snowParticles.forEach((particle) => scene.add(particle));
						snowflakesVisible = true;
					}, 3000);

					// Transform snowflakes to hearts after 30 seconds
					setTimeout(() => {
						snowParticles.forEach((particle, index) => {
							setTimeout(() => {
								const zPos = particle.userData.zPos;
								const depthFactor = (zPos - depthRange.min) / (depthRange.max - depthRange.min);
								const size = 0.8 - depthFactor * 0.4;
								const heartGeometry = create3DHeartGeometry(size);

								const heartMaterial = new THREE.MeshPhongMaterial({
									color: 0xff0000,
									emissive: 0xff0000,
									emissiveIntensity: 0.5,
									shininess: 80,
									transparent: true,
									opacity: 0.9,
									side: THREE.DoubleSide,
								});

								const heart = new THREE.Mesh(heartGeometry, heartMaterial);
								heart.position.copy(particle.position);
								heart.userData = { ...particle.userData };

								scene.remove(particle);
								scene.add(heart);
								snowParticles[index] = heart;
							}, Math.random() * 2000);
						});
					}, 30000);

					// Start fading out music near the end (2:45)
					setTimeout(() => {
						const fadeInterval = setInterval(() => {
							if (backgroundMusic.volume > 0.01) {
								backgroundMusic.volume -= 0.01;
							} else {
								backgroundMusic.pause();
								clearInterval(fadeInterval);
							}
						}, 50);
					}, 165000); // 2:45 (165 seconds)
				}
			});

			// Animation function
			function animate() {
				requestAnimationFrame(animate);

				// Animate explosion particles
				if (explosionParticles.length > 0) {
					const elapsed = Date.now() - explosionTime;
					const progress = Math.min(elapsed / 2000, 1);

					explosionParticles.forEach((particle, i) => {
						const speed = progress < 0.5 ? 0.2 - progress * 0.2 : 0.02;

						particle.position.add(particle.userData.velocity.clone().multiplyScalar(speed));

						particle.rotation.x += particle.userData.rotationSpeed.x * 0.1;
						particle.rotation.y += particle.userData.rotationSpeed.y * 0.1;
						particle.rotation.z += particle.userData.rotationSpeed.z * 0.1;

						if (progress > 0.8) {
							particle.material.opacity = (1 - progress) * 5;
						}

						if (progress === 1) {
							scene.remove(particle);
							if (i === explosionParticles.length - 1) {
								explosionParticles = [];
							}
						}
					});
				}

				// Only animate snow if it's visible
				if (snowflakesVisible) {
					snowParticles.forEach((particle) => {
						particle.position.y -= particle.userData.fallSpeed;
						particle.rotation.z += particle.userData.rotationSpeed;

						particle.position.x =
							particle.userData.initialX +
							Math.sin(Date.now() * particle.userData.wobbleSpeed) *
								particle.userData.wobbleAmplitude;

						if (particle.position.y < -100) {
							particle.position.y = 100;
							particle.position.x = Math.random() * 200 - 100;
							particle.userData.initialX = particle.position.x;
						}
					});
				}

				renderer.render(scene, camera);
			}

			// Handle window resize
			window.addEventListener('resize', onWindowResize, false);

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			// Start animation
			animate();
		</script>
	</body>
</html>
